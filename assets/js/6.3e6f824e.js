(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{252:function(t,a,n){"use strict";n.r(a);var s=n(28),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"js-数据结构和算法实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-数据结构和算法实现"}},[t._v("#")]),t._v(" js 数据结构和算法实现")]),t._v(" "),n("p",[t._v("本项目为js的数据结构和算法的练习，source，test， leecode分别为 实现 数据结构的类/ 测试demo /leecode刷题详解。 目录为js数据算法结构/读书笔记，数据结构的实现，以及leecode的刷题记录。")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 数据结构实现的方法")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  ArrayList"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ArrayList"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  BinarySearchTree"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" BinarySearchTree"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  Dictionary"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Dictionary"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  DoublyLinkedList"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" DoubluLinkedList"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  Graph"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Graph"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  HashTable"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" HashTable"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  LinearProbing"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" LinearProbing"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  LinkedList"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" LinkedList"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  MinCoinChangeByDp"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" minCoinChangeByDp"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  MinCoinChangeByTanXin"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" MinCoinChangeByTanXin"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  Queue"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Queue"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  SeparateChaining"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" SeparateChaining"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  Set"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Set"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  Stack"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Function"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Stack"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[n("a",{attrs:{href:"https://github.com/LuciferKayle/Leecode",target:"_blank",rel:"noopener noreferrer"}},[t._v("源码地址"),n("OutboundLink")],1)]),t._v(" "),n("h3",{attrs:{id:"数组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("js原生支持Array的数据结构，并且自带了一些方法\n\n```\n    push, pop, shift , unshift , indexOf , slice, concat, splice, valueOf , toString\n```\n\n迭代器函数(函数式编程)\n```\n    every, some, forEach, map , sort, filter, reduce\n```\nem: sort 迭代器函数的使用\n")])])]),n("h3",{attrs:{id:"栈"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("栈是一种遵从后进先出(LIFO)原则的有序集合\n\n使用数组实现栈的规则，实现栈的基本方法（入栈，出栈，查找，清除）\n\n```\n    push ， pop， peek， isEmpty， clear， size\n```\n\nem: 十进制的进制转换\n")])])]),n("h3",{attrs:{id:"队列"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[t._v("#")]),t._v(" 队列")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("队列是一种遵从先进先出(FIFO)原则的有序集合\n\n使用数组实现栈的规则，实现栈的基本方法（入队，出队，查找，清除）\n\n```\n    enqueue, dequeue, front, isEmpty, size\n```\n\nem: 优先队列/循环队列的实现\n")])])]),n("h3",{attrs:{id:"链表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("链表的元素存在指针关系\n\n单向链表(单指针)/ 双向链表（双指针）/ 循环链表\n\n```\n    append， insert， removeAt，  remove， isEmpty， size， toString ， getHead\n```\nem： 循环链表的实现\n")])])]),n("h3",{attrs:{id:"集合"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#集合"}},[t._v("#")]),t._v(" 集合")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("集合是由一组无序且唯一(即不能重复)的项组成的， 使用Map实现\n\n```\n    in hasOwnProperty 的区别\n\n    add， remove， has， clear， size\n\n    交/并/差\n    intersection， union， difference\n\n```\n")])])]),n("h3",{attrs:{id:"字典"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#字典"}},[t._v("#")]),t._v(" 字典")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("字典中，我们用[键，值]的形式来存储数据（基于Map实现）\n\n```\n    set, removem, has, get, clear, size, keys, values\n\n```\n")])])]),n("h3",{attrs:{id:"散列表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#散列表"}},[t._v("#")]),t._v(" 散列表")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("HashMap类， 也是字典的一种\n\n为了处理key（HashCode）冲突的问题， 使用了两种方法， 分离链接（separateChaining）和 线性探查（linearProbing）\n\n```\n    put remove get\n\n    // 更加好的散列函数\n\n    var djb2HashCode = function(key) {\n        var hash = 5381\n        for (let i = 0; i < key.length; i++) {\n            hash = hash*33 + key.charCodeAt(i)           \n        }\n\n        return hash % 1013\n    } \n    \n```\n")])])]),n("h3",{attrs:{id:"树（非顺序数据结构）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#树（非顺序数据结构）"}},[t._v("#")]),t._v(" 树（非顺序数据结构）")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("二叉树和二叉搜索树（BST）bi\n目前只研究二叉搜索树，只允许左边节点存储小的值， 在右侧节点存储大的值\n\n```\n    insert， search，max， min， remove\n    inOrderTraverseNode（中序遍历）， 从最小到最大的顺序访问所有节点\n    preOrderTraverse (先序遍历) ，以优先于后代节点的顺序访问每个节点的\n    postOrderTraverse（后续遍历），先访问节点的后代节点，再访问节点本身。\n```\n")])])]),n("h3",{attrs:{id:"图"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#图"}},[t._v("#")]),t._v(" 图")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("实现方法：邻接矩阵，邻接表， 关联矩阵， 此处使用邻接矩阵实现\n\n```\n    addVertex, addEdge, toString, BFS, DFS\n```\n")])])]),n("table",[n("thead",[n("tr",[n("th",[t._v("算法")]),t._v(" "),n("th",[t._v("数据结构")]),t._v(" "),n("th",[t._v("描述")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("深度优先搜索")]),t._v(" "),n("td",[t._v("栈")]),t._v(" "),n("td",[t._v("通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问")])]),t._v(" "),n("tr",[n("td",[t._v("广度优先搜索")]),t._v(" "),n("td",[t._v("队列")]),t._v(" "),n("td",[t._v("通过将顶点存入队列中（在第4章中学习过），最先入队列的顶点先被探索")])])])]),t._v(" "),n("h3",{attrs:{id:"排序和搜索算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#排序和搜索算法"}},[t._v("#")]),t._v(" 排序和搜索算法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("多种排序方式的实现\n\n```\n    bubbleSort, selectionSort, insertionSort, mergeSort, quickSort\n```\n\n查找方式： 顺序查找和二分查找\n\n```\n    sequentialSearch, binarySearch\n```\n")])])]),n("h3",{attrs:{id:"算法补充知识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#算法补充知识"}},[t._v("#")]),t._v(" 算法补充知识")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("递归函数\nrecursiveFunction \n\n动态规划（最少找零问题实现）\n\n贪心算法\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);